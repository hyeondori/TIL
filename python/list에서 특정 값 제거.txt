오늘은 pandas DataFrame에서 특정 값만을 추출하여 리스트로 저장하는데,
그 건이 매우 많은(1건에 약 20개 정도 되는데 약 75만건)... 문제를 당면했다.

동료가 개발한 추천 시스템에서 추천 결과를 저장해야 하는 문제였는데, 해당 추천 시스템은 처음부터 끝까지 더이상 에러는 없는 상태로
모두 검증이 마친 상태였다.

그러나, 본격적인 문제는 여기서 부터였는데 75만건의 고객 데이터를 유사도 기반으로 추천한 후, 이리저리 재조합하여 추천 상품을 리스팅하는 코드에서
성능 이슈가 발생한 것이다.

이 문제를 해결하기 위해 갖가지 노력을 다했다.

내가 낸 안건은

1. python 내에서 효율을 끌어올린다.
2. 모든 방법을 동원하여 해결되지 않을 경우, DB 단에서 해결한다.

이렇게 2건이었다.

가장 이상적이고 개발자다운 방식으로 1번을 고민하기 시작했다.

첫 단계는 DataFrame에서 작동하던 코드를 모두 python list 형태로 변환하여 진행해 보는 것이었다.

여기서 문제가 됐던 것은 숫자와 문자의 조합으로 이루어진 데이터(Ex. 1234_ASDF_EFG)와 문자로만 이루어진 데이터(Ex. HIJK_LMF)가 혼재되어 있는 상태에서
숫자와 문자가 함께 있는 데이터만 남긴 후 숫자만 추출하는 것이 과제이고 이를 가장 효율적으로 하는 방법에 대해서 고찰하기 시작했다.

왜냐하면 75만건을 뽑아야 하는 상황에서 1건에 평균 0.3초 가량 걸리는 이슈가 있었기 때문이다.
해당 문제만 발생하는 것이 아니라 여러 문제가 복합적이어서 최종적으로 75만건을 추출하기 위해 자원을 풀로 당겨 썼을 때 3달의 시간이 걸리는 상황이었다.

문제가 list로 되어 있는 상황에서 나는 for 문을 쓰지 않고서는 해당 문제를 해결할 수 없다고 생각했다.
또 해당 문제에서 숫자와 문자가 혼재된 데이터는 매우 많지만 문자만 있는 데이터는 많아봐야 20가지 이내로 이루어져 있었다.

그래서 나는 포함될 수 있는 문자 데이터를 하나의 리스트로 선언하고, 이를 for 문으로 not in 비교를 함을 통해 성능을 내는 방법을 고민했다.

그런 와중에 python list comprehension를 통해 조금 더 효율적으로 내가 원하는 형태를 구현하는 방식을 찾았는데, 이는 다음과 같다.

li = [1234_ASDF_EFG, 2134_ASDF_EFG, HIJK_LMF, 2341_ASDF_EFG, IKEL_LMF, 7123_ASDF_EFG, 8920_ASDF_EFG]
remove_set = {HIJK_LMF, IKEL_LMF}

li = [i for i in li if i not in remove_set]
print(li)

위의 방법은 내가 고민해본 방법 중에서는 list에서 특정한 원소를 제거하기 위해 가장 효율적인 방법이 아닌가 생각한다.
현재 당면한 문제가 이를 통해 해소가 될지는 아직 미지수이나 꽤 그럴싸한 결론이라 생각이 되어 기록한다.